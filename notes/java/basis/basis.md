谈谈你对java的理解
1.平台无关性
  编译器(javac指令)编译成字节码,放在class文件,通过java虚拟机进行字节码解析成系统能执行的机器码(一次编译,到处运行)
  javap -c 指令进行反汇编,查看字节码
2.GC(与C++比较)
3.语言特性(放射、泛型、lamda等)
4.面向对象(封装、继承、多态)
5.类库
6.异常处理

反射
Java反射机制是在运行状态中,对于任意一个类都能够知道这个类的所有属性和方法;对于任意一个对象,都能调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制;
优点:使代码更加灵活
缺点:安全隐患,比如可以无视泛型的安全检查(泛型的安全检查发生在编译时);性能较差(实际影响不大)
获取class的四种方式
1.Class c = Object.class; //不会初始化
2.Class.forName("com.yyk.iv.xxx"); //对class进行了初始化静态代码块会被执行,静态变量会进行初始化
3.Class c = ClassLoader.loadCla("com.yyk.iv.xxx"); //不会初始化
4.Object o = new Object();
  o.getClass;
框架中的动态代理也是依赖反射来实现的;

ClassLoader
主要工作在Class装载的加载阶段,主要作用是从系统外部获得Class二进制数据流.它是Java的核心组件,所有的Class都是由ClassLoader进行加载的,ClassLoader负责通过将class文件的二进制数据流装载进系统,然后交给虚拟机进行连接、初始化等操作.
主要方法 loadClass();
ClassLoader的种类
BootStrapClassLoader: c++编写,加载核心库java.*
ExtClassLoader:Java编写,加载扩展库javax.*
AppClassLoader:Java编写,加载程序所在目录
自定义ClassLoader的实现
关键函数 findClass()  defineClass();

类加载器的双亲委派机制
1.自下而上检查类加载器是否已经加载
2.自上而下尝试加载类(在指定目录寻找是否有对应Class)
查看classLoader -> loadClass()源码

为什么要使用双亲委派机制去加载类
避免多份同样字节码加载

类的加载方式
隐式加载:new  //不需要newInstance()即可获得对象
显式加载:loadClass,forName等

类的装载过程
1.加载 ClassLoader加载class字节码,生成Class对象
2.链接 校验:检查加载的class的正确性和安全性 准备:为类变量分配存储空间并设置类变量初始值 解析:JVM将常量池内的符号引用转换为直接引用
3.初始化 执行类变量赋值和静态代码块

内存简介
内存的逻辑地址和物理地址进行映射
32位处理器:2^32
64位处理器:2^64
地址空间的划分
内核空间
用户空间:java使用的空间

JVM内存模型-JDK8
线程私有
1.程序计数器
  当前线程所执行代码的字节码行号指示器(逻辑计数器)
  改变计数器的值来选取下一条需要执行的字节码指令(实现循环,分支,跳转,线程恢复,异常处理)
  和线程一一对应,即线程私有(为了线程切换后恢复到正确的指令)
  对Java方法计数,Native方法计数器值为undefined
  不会发生内存泄漏
2.虚拟机栈
  Java方法执行的内存模型
  包含多个栈帧,栈帧存储了局部变量表,操作栈,动态链接,返回地址等信息
    局部变量表:包含方法执行过程中的所有变量(基础类型,引用类型)
    操作数栈:入栈、出栈、复制、交换、产生消费变量
3.本地方法栈
  和虚拟机栈类似,调用native方法时使用本地方法栈

线程共享
MetaSpace(元空间 1.8以后)
堆(包含常量池)

递归为什么会引起stackOverFlowError
一个方法的执行就代表一个栈帧的入栈和出栈,当递归过深,栈帧数超出虚拟机栈深度,造成stackOverFlowError

元空间(MetaSpace 1.8) 与永久代(PermGen 1.7或之前版本)的区别,均是方法区的实现(方法区只是一种JVM的规范),存储Class的属性(Method、Field等)
  元空间使用本地内存,永久代使用的时JVM的内存
  
MetaSpace相比PermGen的优势
1.字符串常量池存在永久代中,容易出现性能问题和内存溢出(OOM:PermGen) -> 字符串常量池于JDK1.7转移到堆中,其他常量池依然在方法区
2.类和方法的信息大小难以确定,给永久代的大小指定带来困难
3.永久代会为GC带来不必要的复杂性
4.方便HotSpot与其他JVM如Jrockit的集成(永久代为HotSpot特有)

