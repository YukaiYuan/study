JVM如何加载.class文件
class Loader加载class文件,Execution Engine进行解析

内存简介
内存的逻辑地址和物理地址进行映射
32位处理器:2^32
64位处理器:2^64
地址空间的划分
内核空间
用户空间:java使用的空间

JVM内存模型-JDK8
线程私有
1.程序计数器
  当前线程所执行代码的字节码行号指示器(逻辑计数器)
  改变计数器的值来选取下一条需要执行的字节码指令(实现循环,分支,跳转,线程恢复,异常处理)
  和线程一一对应,即线程私有(为了线程切换后恢复到正确的指令)
  对Java方法计数,Native方法计数器值为undefined
  不会发生内存泄漏
2.虚拟机栈
  Java方法执行的内存模型
  包含多个栈帧,栈帧存储了局部变量表,操作栈,动态链接,返回地址等信息
    局部变量表:包含方法执行过程中的所有变量(基础类型,引用类型)
    操作数栈:入栈、出栈、复制、交换、产生消费变量
3.本地方法栈
  和虚拟机栈类似,调用native方法时使用本地方法栈

线程共享
MetaSpace(元空间 1.8以后)
堆(包含常量池)

递归为什么会引起stackOverFlowError
一个方法的执行就代表一个栈帧的入栈和出栈,当递归过深,栈帧数超出虚拟机栈深度,造成stackOverFlowError

元空间(MetaSpace 1.8) 与永久代(PermGen 1.7或之前版本)的区别,均是方法区的实现(方法区只是一种JVM的规范),存储Class的属性(Method、Field等)
  元空间使用本地内存,永久代使用的时JVM的内存
  
MetaSpace相比PermGen的优势
1.字符串常量池存在永久代中,容易出现性能问题和内存溢出(OOM:PermGen) -> 字符串常量池于JDK1.7转移到堆中,其他常量池依然在方法区
2.类和方法的信息大小难以确定,给永久代的大小指定带来困难
3.永久代会为GC带来不必要的复杂性
4.方便HotSpot与其他JVM如Jrockit的集成(永久代为HotSpot特有)

JVM三大性能调优参数 -Xms -Xmx -Xss的含义
java -Xms128m -Xmx128m -Xss256k -jar xxx.jar
-Xss:规定了每个线程虚拟机栈的大小
-Xms:堆的初始值(不够时扩容)
-Xmx:堆能达到的最大值 (-Xms -Xmx一般设置为一样,堆扩容时会发生内存抖动,影响程序稳定性)

Java内存模型中堆和栈的区别-内存分配策略
静态存储:编译时确定每个数据目标在运行时的存储空间需求(不允许有可变数据结构的存在,也不允许有嵌套、递归的结构出现,因为无法计算准确的存储空间)
栈式存储:数据区需求在编译时未知,运行时模块入口前确定(运行时必须知道准确的内存分配)
堆式存储:编译时或运行时模块入口都无法确定,动态分配(如可变长度窜或对象实例)

Java内存模型中堆和栈的区别(栈中存储的引用变量,执向堆中的对象实例)
管理方式:栈自动释放,堆需要GC
空间大小:栈比堆小
碎片相关:栈产生的碎片远小于堆
分配方式:栈支持静态和动态分配,而堆只支持动态分配
效率:栈的效率比堆高

不同JDK版本之间intern()方法的区别-JDK6 VS JDK6+
JDK6:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,将此字符串对象添加到字符串常量池中,并且返回该字符串对象的引用
JDK6+:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,如果该字符串对象已经存在于Java堆中,则将堆中对此对象的引用添加到字符串常量池中,并且返回该引用;如果堆中不存在,则在池中创建该字符串并返回其引用;

GC
对象被判定为垃圾的标准
没有被其他对象引用
1.引用计数算法
  通过判断对象的引用数量来决定对象是否可以被回收
  每个对象实例都有一个引用计数器,被引用则+1,完成引用则-1
  任何引用计数为0的对象可以作为垃圾回收
优点:执行效率高,程序执行受影响较小
缺点:无法检测出循环引用的情况,导致内存泄漏
2.可达性分析算法
通过判断对象的引用链是否可达来决定对象是否可以被回收
GCRoot开始分析可达性,引用到的标记为存活

可以作为GC root的对象
1.虚拟机栈中的引用对象(栈帧中的本地变量表引用的对象)
2.方法区中的常量引用的对象
3.方法区中的类静态属性引用的对象
4.本地方法中JNI(Native方法)的引用对象
5.活跃线程的引用对象

垃圾回收算法
1.标记-清除算法(Mark and Sweep)
标记:从根集合进行扫描,对存活的对象进行标记
清除:对堆内存从头到尾进行线性遍历,回收不可达对象
缺点:容易造成碎片化

2.复制算法(Copying)
分为对象面和空闲面
对象在对象面上创建
存活的对象被从对象面复制到空闲面
将对象面所有的对象内存清除
优点:解决碎片化问题;顺序分配内存,简单高效;适用于对象存活率低的场景(年轻代)
缺点:对象存活率高时要复制的对象多,效率低;需要额外的内存空间

3.标记-整理算法(Compacting) -> 老年代
标记:从根集合进行扫描,对存活的对象进行标记
清除:移动所有的存活的对象,且按照内存地址次序依次排列,然后将末端内存地址以后的内存全部回收(成本比标记-清除算法高)
避免内存的不连续性
不用设置两块内存互换
适用于存活率高的场景

4.分代收集算法(Generational Collector)
垃圾回收的组合拳
按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
目的:提高JVM垃圾回收效率

GC的分类
Minor GC:年轻代GC
Full GC:老年代的GC往往伴随着年轻代的GC






 
