JVM如何加载.class文件
class Loader加载class文件,Execution Engine进行解析

内存简介
内存的逻辑地址和物理地址进行映射
32位处理器:2^32
64位处理器:2^64
地址空间的划分
内核空间
用户空间:java使用的空间

JVM内存模型-JDK8
线程私有
1.程序计数器
  当前线程所执行代码的字节码行号指示器(逻辑计数器)
  改变计数器的值来选取下一条需要执行的字节码指令(实现循环,分支,跳转,线程恢复,异常处理)
  和线程一一对应,即线程私有(为了线程切换后恢复到正确的指令)
  对Java方法计数,Native方法计数器值为undefined
  不会发生内存泄漏
2.虚拟机栈
  Java方法执行的内存模型
  包含多个栈帧,栈帧存储了局部变量表,操作栈,动态链接,返回地址等信息
    局部变量表:包含方法执行过程中的所有变量(基础类型,引用类型)
    操作数栈:入栈、出栈、复制、交换、产生消费变量
3.本地方法栈
  和虚拟机栈类似,调用native方法时使用本地方法栈
  
递归为什么会引起stackOverFlowError
一个方法的执行就代表一个栈帧的入栈和出栈,当递归过深,栈帧数超出虚拟机栈深度,造成stackOverFlowError

线程共享
MetaSpace(元空间 1.8以后)
堆(包含常量池)

元空间(MetaSpace 1.8) 与永久代(PermGen 1.7或之前版本)的区别,均是方法区的实现(方法区只是一种JVM的规范),存储Class的属性(Method、Field等)
  元空间使用本地内存,永久代使用的时JVM的内存
  
MetaSpace相比PermGen的优势
1.字符串常量池存在永久代中,容易出现性能问题和内存溢出(OOM:PermGen) -> 字符串常量池于JDK1.7转移到堆中,其他常量池依然在方法区
2.类和方法的信息大小难以确定,给永久代的大小指定带来困难
3.永久代会为GC带来不必要的复杂性
4.方便HotSpot与其他JVM如Jrockit的集成(永久代为HotSpot特有)

JVM三大性能调优参数 -Xms -Xmx -Xss的含义
java -Xms128m -Xmx128m -Xss256k -jar xxx.jar
-Xss:规定了每个线程虚拟机栈的大小
-Xms:堆的初始值(不够时扩容)
-Xmx:堆能达到的最大值 (-Xms -Xmx一般设置为一样,堆扩容时会发生内存抖动,影响程序稳定性)

Java内存模型中堆和栈的区别-内存分配策略
静态存储:编译时确定每个数据目标在运行时的存储空间需求(不允许有可变数据结构的存在,也不允许有嵌套、递归的结构出现,因为无法计算准确的存储空间)
栈式存储:数据区需求在编译时未知,运行时模块入口前确定(运行时必须知道准确的内存分配)
堆式存储:编译时或运行时模块入口都无法确定,动态分配(如可变长度窜或对象实例)

Java内存模型中堆和栈的区别(栈中存储的引用变量,执向堆中的对象实例)
管理方式:栈自动释放,堆需要GC
空间大小:栈比堆小
碎片相关:栈产生的碎片远小于堆
分配方式:栈支持静态和动态分配,而堆只支持动态分配
效率:栈的效率比堆高

不同JDK版本之间intern()方法的区别-JDK6 VS JDK6+
JDK6:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,将此字符串对象添加到字符串常量池中,并且返回该字符串对象的引用
JDK6+:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,如果该字符串对象已经存在于Java堆中,则将堆中对此对象的引用添加到字符串常量池中,并且返回该引用;如果堆中不存在,则在池中创建该字符串并返回其引用;

GC
对象被判定为垃圾的标准
没有被其他对象引用
1.引用计数算法
  通过判断对象的引用数量来决定对象是否可以被回收
  每个对象实例都有一个引用计数器,被引用则+1,完成引用则-1
  任何引用计数为0的对象可以作为垃圾回收
优点:执行效率高,程序执行受影响较小
缺点:无法检测出循环引用的情况,导致内存泄漏
2.可达性分析算法
通过判断对象的引用链是否可达来决定对象是否可以被回收
GCRoot开始分析可达性,引用到的标记为存活

可以作为GC root的对象
1.虚拟机栈中的引用对象(栈帧中的本地变量表引用的对象)
2.方法区中的常量引用的对象
3.方法区中的类静态属性引用的对象
4.本地方法中JNI(Native方法)的引用对象
5.活跃线程的引用对象

垃圾回收算法
1.标记-清除算法(Mark and Sweep)
标记:从根集合进行扫描,对存活的对象进行标记
清除:对堆内存从头到尾进行线性遍历,回收不可达对象
缺点:容易造成碎片化

2.复制算法(Copying)
分为对象面和空闲面
对象在对象面上创建
存活的对象被从对象面复制到空闲面
将对象面所有的对象内存清除
优点:解决碎片化问题;顺序分配内存,简单高效;适用于对象存活率低的场景(年轻代)
缺点:对象存活率高时要复制的对象多,效率低;需要额外的内存空间

3.标记-整理算法(Compacting) -> 老年代
标记:从根集合进行扫描,对存活的对象进行标记
清除:移动所有的存活的对象,且按照内存地址次序依次排列,然后将末端内存地址以后的内存全部回收(成本比标记-清除算法高)
避免内存的不连续性
不用设置两块内存互换
适用于存活率高的场景

4.分代收集算法(Generational Collector)
垃圾回收的组合拳
按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
目的:提高JVM垃圾回收效率

GC的分类
Minor GC:年轻代GC
Full GC:老年代的GC往往伴随着年轻代的GC

年轻代:尽可能快速的收集掉那些生命周期短的对象
Eden,SurvivorTo,SurvivorFrom
没经过一次Minor GC对象的分代年龄+1,年龄到一定值后会晋升到老年代(默认15, 通过 -XX:MaxTenuringThreshold 可设置晋升年龄)

对象如何晋升到老年代
1.经历一定Minor次数依然存活的对象
2.Survivor区或Eden区放不下的对象,直接在老年代中生成
3.新生成的大对象(-XX:+PretenuerSizeThreshold)

常用的调优参数
-XX:SurvivorRatio:Eden和一个Survivor的比值,默认8:1
-XX:NewRatio:老年代和年轻代内存大小的比例
-XX:MaxTenuringThreshold:晋升年龄

老年代:存放生命周期较长的对象
FullGC 和MajorGC
FullGC比MinorGC执行慢,出发频率低

触发FullGC的条件
1.老年代空间不足
2.永久代空间不足
3.CMS GC时出现promotion failed,concurrent mode failure
4.MinorGC晋升到老年代的平均大小大于老年代的剩余空间
5.调用System.gc();
6.使用RMI来进行RPC或管理的JDK应用,默认每小时执行一次FullGC

Stop-the-World

SafePoint
分析过程中对象引用关系不会发送变化的点
产生SafePoint的点:方法调用;循环跳转;异常跳转等

JVM的运行模式
Server(启动较慢,运行速度较快,重量级)
Client(轻量级)

常见的垃圾收集器
年轻代垃圾收集器:
Serial收集器(-XX:+UseSerialGC,复制算法):单线程收集,进行垃圾收集时,必须暂停所有工作线程;简单高效,Client模式下默认的年轻代收集器
ParNew收集器(-XX:+UseParNewGC,复制算法):多线程手机,其余行为、特点和Serial收集器一样;单核效率不如Serial,在多核下执行才有优势
Parallel Scavenge收集器(-XX:+useParallelGC,复制算法):更关注系统的吞吐量,在多核下执行才有有事,Server模式下默认的年轻代收集器

老年代垃圾收集器
Serial Old收集器(-XX:UseSerialOldGC,标记-整理算法):单线程手机,进行垃圾收集时,必须暂停所有的工作线程;简单高效,Client模式下默认的老年代收集器
Parallel Old收集器(-XX:UseParallelOldGC,标记-整理算法):多线程,吞吐量优先
CMS收集器(-XX:UseConcMarkSweepGC,标记-清楚算法):几乎没有暂停时间(与用户线程并发执行)
  1.初始标记:stop-the-world
  2.并发标记:并发追溯标记,程序不会停顿
  3.并发预清理:查找执行并发标记阶段从年轻代晋升到老年代的对象
  4.重新标记:暂停虚拟机,扫描CMS堆中的剩余对象
  5.并发清理:清理垃圾对象,程序不会停顿
  6.并发重置:重置CMS收集器的数据结构
  
G1(Garbage First)收集器(-XX:+UseG1GC,年轻代老年代共用,复制+标记-整理算法):
  1.并发和并行
  2.分代收集
  3.空间整合
  4.可预测的停顿
 会将整个Java堆内存划分成多个大小相等的Region
 年轻代和老年代不再物理隔离
 
Object的finalize()方法的作用是否与C++的析构函数作用相同
当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

Java中的强引用,软引用,弱引用,虚引用有什么用
强引用(Strong Reference)
  最普遍的引用:Object obj = new Object();
  抛出OOM终止程序也不会回收具有强引用的对象
  可通过将对象设置为null来弱化引用,使其被回收
软引用(Soft Reference)
  对象处在有用但非必须的状态
  当内存空间不足时,GC会回收该引用的对象的内存
  可以来实现高速缓存
  String str = new String("abc");//强引用
  SoftReference<String> softRef = new SoftReference<String>(str);//软引用
弱引用(Weak Reference)
  非必须的对象,比软引用更弱一些
  GC时会被回收
  被回收的概率也不大,因为GC线程的优先级比较低
  适用于引用偶尔被使用且不影响垃圾回收的对象
  String str = new String("abc");//强引用
  WeakReference<String> weakRef = new WeakReference<String>(str);//弱引用
虚引用(PhantomReference)
  不会决定对象的生命周期
  任何时候都可能被GC
  跟踪对象被垃圾收集器回收的活动,起标记、哨兵作用
  必须和引用队列ReferenceQueue联合使用
  String str = new String("abc");//强引用
  ReferenceQueue queue = new ReferenceQueue();
  PhantomReference ref = new PhantomReference(str,queue);//虚引用
  
引用队列(ReferenceQueue)
  无实际存储结构,存储逻辑依赖于内部节点之间的关系来表达
  存储关联的且被GC的软引用,弱引用及虚引用
  
  






 
