JVM如何加载.class文件
class Loader加载class文件,Execution Engine进行解析

内存简介
内存的逻辑地址和物理地址进行映射
32位处理器:2^32
64位处理器:2^64
地址空间的划分
内核空间
用户空间:java使用的空间

JVM内存模型-JDK8
线程私有
1.程序计数器
  当前线程所执行代码的字节码行号指示器(逻辑计数器)
  改变计数器的值来选取下一条需要执行的字节码指令(实现循环,分支,跳转,线程恢复,异常处理)
  和线程一一对应,即线程私有(为了线程切换后恢复到正确的指令)
  对Java方法计数,Native方法计数器值为undefined
  不会发生内存泄漏
2.虚拟机栈
  Java方法执行的内存模型
  包含多个栈帧,栈帧存储了局部变量表,操作栈,动态链接,返回地址等信息
    局部变量表:包含方法执行过程中的所有变量(基础类型,引用类型)
    操作数栈:入栈、出栈、复制、交换、产生消费变量
3.本地方法栈
  和虚拟机栈类似,调用native方法时使用本地方法栈

线程共享
MetaSpace(元空间 1.8以后)
堆(包含常量池)

递归为什么会引起stackOverFlowError
一个方法的执行就代表一个栈帧的入栈和出栈,当递归过深,栈帧数超出虚拟机栈深度,造成stackOverFlowError

元空间(MetaSpace 1.8) 与永久代(PermGen 1.7或之前版本)的区别,均是方法区的实现(方法区只是一种JVM的规范),存储Class的属性(Method、Field等)
  元空间使用本地内存,永久代使用的时JVM的内存
  
MetaSpace相比PermGen的优势
1.字符串常量池存在永久代中,容易出现性能问题和内存溢出(OOM:PermGen) -> 字符串常量池于JDK1.7转移到堆中,其他常量池依然在方法区
2.类和方法的信息大小难以确定,给永久代的大小指定带来困难
3.永久代会为GC带来不必要的复杂性
4.方便HotSpot与其他JVM如Jrockit的集成(永久代为HotSpot特有)

JVM三大性能调优参数 -Xms -Xmx -Xss的含义
java -Xms128m -Xmx128m -Xss256k -jar xxx.jar
-Xss:规定了每个线程虚拟机栈的大小
-Xms:堆的初始值(不够时扩容)
-Xmx:堆能达到的最大值 (-Xms -Xmx一般设置为一样,堆扩容时会发生内存抖动,影响程序稳定性)

Java内存模型中堆和栈的区别-内存分配策略
静态存储:编译时确定每个数据目标在运行时的存储空间需求(不允许有可变数据结构的存在,也不允许有嵌套、递归的结构出现,因为无法计算准确的存储空间)
栈式存储:数据区需求在编译时未知,运行时模块入口前确定(运行时必须知道准确的内存分配)
堆式存储:编译时或运行时模块入口都无法确定,动态分配(如可变长度窜或对象实例)

Java内存模型中堆和栈的区别(栈中存储的引用变量,执向堆中的对象实例)
管理方式:栈自动释放,堆需要GC
空间大小:栈比堆小
碎片相关:栈产生的碎片远小于堆
分配方式:栈支持静态和动态分配,而堆只支持动态分配
效率:栈的效率比堆高

不同JDK版本之间intern()方法的区别-JDK6 VS JDK6+
JDK6:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,将此字符串对象添加到字符串常量池中,并且返回该字符串对象的引用
JDK6+:当调用intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中该字符串的引用.否则,如果该字符串对象已经存在于Java堆中,则将堆中对此对象的引用添加到字符串常量池中,并且返回该引用;如果堆中不存在,则在池中创建该字符串并返回其引用;
